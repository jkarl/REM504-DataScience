---
title: "Making Maps in R"
output: html_notebook
---

This is basic example of how to create maps with ggplot. We're using some data layers generated by the JournalMap project on article study area locations.

```{r}
library(ggplot2) ## Plotting
library(rgdal)  ## Reading/writing spatial files
library(maptools)
library(dplyr)


## I'm going to be lazy and set the working directory today.
data.path <- "C:\\Users\\Jason Karl\\Documents\\GitHub\\REM504-DataScience\\Practice_Datasets"
setwd(data.path)

## Read in a couple of shapefiles
countries <- readOGR(dsn="countries.shp",layer="countries") # Specify the shapefile as the data source name
countries <- readOGR(dsn=".",layer="countries") # Also works to specify "." as dsn
countries.dd <- spTransform(countries, CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0")) # My countries were in a projected coordinate system. Needed to convert to geographic decimal decrees

plos_blocks <- readOGR(dsn=".", layer="PLOS_re_5deg_blocks",stringsAsFactors = FALSE)
```

### Crappy plots
You can use the basic __plot()__ functions to take a quick look at any spatial object in R. These plots aren't much use for anything else, though.
```{r}
plot(countries)
plot(plos_blocks)
```

### Building a map with ggplot
You can use ggplot to build maps from spatial objects in R. You just need a couple of extra layers to the ggplot function.
```{r}
countries.dd@data$id <- row.names(countries.dd@data)
countries.df <- fortify(countries.dd, group=id)
map <- ggplot()+
  geom_polygon(data=countries.df, aes(x=long,y=lat,group=group), # Add the countries
               fill="#DDDDDD",color="#AAAAAA",size=0.5)+ #make them look 
  coord_map() # This stretches the map to fill the space.
map

```
OK. That's basic, but it's a start. Let's apply some styling and clean up the borders
```{r}
map <- map + labs(x="", y="", title="PLOS Article Locations, RegEx Parser")+
  theme(axis.ticks.y = element_blank(), axis.text.y = element_blank(),
        axis.ticks.x = element_blank(), axis.text.x = element_blank(),
        panel.grid = element_blank(), 
        panel.background = element_rect(fill="#9ecae1",color="#333333"))
        #plot.margin = unit(c(0,0,0,0),"points"))
map
```
That's starting to look pretty close to what we want. Let's add the 5-degree blocks and color-code them by article count.
```{r}
plos_blocks@data$id <- row.names(plos_blocks@data)
block.verts <- fortify(plos_blocks, region="id") # Fortify turns a Spatial Data Frame into a regular data frame. GGPLOT needs regular data frames.
blocks.df <- merge(block.verts, plos_blocks@data, by="id") # Merge the attributes into the new data frame.
blocks.df <- blocks.df[blocks.df$PNT_COUNT>0,] # Screen out empty blocks
map+geom_polygon(data=blocks.df, # Add the polygons
                 aes(x=long,y=lat,group=group,
                     fill=PNT_COUNT),alpha=0.8,
                     color="black",size=0.5)+
    scale_fill_manual(values=c('#ffffd4', # Create the color ramp
                        '#fee391',
                        '#fec44f',
                        '#fe9929',
                        '#ec7014',
                        '#cc4c02',
                        '#8c2d04'), 
                      breaks = c(1,3,5,8,21),guide=FALSE) #guides=FALSE turns off the legend.
```

Let's remake that figure using a google map service as the background. We'll use the ggmap library for this.
```{r}
library(ggmap)
map <- get_googlemap(center=c(lat=0,lon=0), zoom=2, size=c(640,500), scale=2) %>% ggmap(extent="device") + coord_map()
map + geom_polygon(data=blocks.df, aes(x=long,y=lat,group=group,fill=PNT_COUNT),alpha=0.8,color="black",size=0.5)+
  scale_fill_manual(values=c('#ffffd4','#fee391','#fec44f','#fe9929','#ec7014','#cc4c02','#8c2d04'), breaks = c(1,3,5,8,21),guide=FALSE)
```
Well, need to play around with the extents, sizing, etc., but you get the idea. ggmap gives access to other map tile services too like Open Streetmap and Stamen Maps. Pretty helpful for if/when you just need to drop some features on top of a generic basemap.

### Dynamic maps with Leaflet
What about if you wanted to have some dynamic/interactive maps? The Leaflet package can do that!
```{r}
library(leaflet)
plos.gt0 <- plos_blocks[plos_blocks$PNT_COUNT>0,] # Get the non-zero tiles
plos.gt0@data$PNT_COUNT <- as.numeric(plos.gt0@data$PNT_COUNT) # need to convert to numeric so the color palette works properly
# color ramping is a bit different with leaflet. Need to set up a palette
bins <- c(1, 3, 5, 8, Inf)
pal <- colorBin("YlOrRd", domain = plos.gt0$PNT_COUNT, bins = bins)
lmap <- leaflet(plos.gt0, width=640,height=320) %>% ## Set up the leaflet object with the default layer
  addProviderTiles("Hydda.Base") # Add the background tile service
lmap %>% addPolygons(fillColor = ~pal(PNT_COUNT), # Add the polygons
  weight = 1,
  opacity = 0.7,
  color = "black",
  fillOpacity = 0.7,
  label=as.character(plos.gt0$PNT_COUNT)) # You can add popup labels too!
```

