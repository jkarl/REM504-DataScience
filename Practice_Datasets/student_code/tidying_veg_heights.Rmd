---
title: "Tidying Data: Vegetation Height Example"
author: "Nelson Stauffer"
output:
  html_document:
    df_print: paged
---

This particular data set is from Montana and represents vegetation height values from two different measurement protocols. Both protocols were performed on the same plot and along the same transects on those plots, recording heights at regular intervals for woody and non-woody plants as separate observations.

Unfortunately, the name of the plot and the date of sampling are in cells above the data and the labels of which transect values belong to are floating in the row above the column headers. Additionally, the number of transects and therefore the number of columns in the data set varies by plot. Also, the height methods are comingled with the distance along the transect in meters having "AIM" prepended for those observations.

```{r read}
# Read in the data
# I'm pulling in only the first sheet (because I know it's where the data lives)
# I also skip the first two rows because they have non-tabular data
data.raw <- readxl::read_excel("C:/Users/Nelson/Documents/Projects/GitHub/REM504-DataScience/Practice_Datasets/student_data/vegetation_height_data.xlsx",
                               sheet = 1,
                               skip = 2)

# The plot name and sampling date are in that first row near the origin, so I'll grab them
# Because I'm getting just one row, I don't want to 
metadata <- readxl::read_excel("C:/Users/Nelson/Documents/Projects/GitHub/REM504-DataScience/Practice_Datasets/student_data/vegetation_height_data.xlsx",
                               sheet = 1,
                               range = "A1:G1",
                               col_names = FALSE)
# Several of these were empty, so I'm dropping them because they're irrelevant.
# I'm using unlist() to turn the data frame into a vector because I don't want a data frame here
metadata <- unlist(metadata)[!is.na(unlist(metadata))]

# I know that they're always going to be in the order of plot name, sample date, so I'll name them
names(metadata) <- c("plot", "date.sampled")
```

My ideal data set for this is very simple with each observation consisting of eight variables:

* Plot ID (character string)
* Sample Date (some kind of date object)
* Transect ID (numeric)
* Point (numeric, representing the point on the transect where the measurement was taken)
* Protocol (character string, either "AIM" or "HAF")
* Vegetation Type (character string, either "woody" or "nonwoody")
* Species Code (character string)
* Height (numeric)
* Height Units (character string)

First, I'll take each of the transects' data and stack them so that they aren't side-by-side, which will get me most of the way there.
```{r tall}
# If there are four columns per transect (woody and non-woody codes and heights), the number of transects is equal to the number of columns, minus the "Point" column, divided by 4
transect.count <- (ncol(data.raw) - 1)/4

# I can use that to create a list of vectors of column indices corresponding to each transect
# I'm offsetting by 2 instead of 1 because I'm skipping the "Point" column
transect.cols <- lapply(1:transect.count,
                        FUN = function(X){
                          # Vector always starts with 1, then gets the range for the other four
                          c(1, (2 + 4*(X - 1)):(1 + 4 * X))
                        })

# And now I'll use that list of vectors to get a list of data frames with only those columns
# I'll also rename the columns and create new ones
data.list <- lapply(transect.cols,
                    FUN = function(X, data){
                      # Get just this subset of data
                      data.current <- data[,X]
                      
                      # Split into woody and nonwoody to perform the same operations on each
                      data.woody <- data.current[, 1:3]
                      # Add in the veg type
                      data.woody$veg.type <- "woody"
                      # Get the height units from the height column name
                      data.woody$height.units <- stringr::str_extract(stringr::str_extract(names(data.woody)[3], pattern = "\\([A-z]{1,4}\\)"), pattern = "[A-z]{1,4}")
                      # Rename the species code and height column names to be reasonable
                      names(data.woody)[2:3] <- c("species.code", "height")
                      
                      data.nonwoody <- data.current[, c(1,4:5)]
                      data.nonwoody$veg.type <- "nonwoody"
                      data.nonwoody$height.units <- stringr::str_extract(stringr::str_extract(names(data.nonwoody)[3], pattern = "\\([A-z]{1,4}\\)"), pattern = "[A-z]{1,4}")
                      names(data.nonwoody)[2:3] <- c("species.code", "height")
                      
                      # Combine the two data frames
                      data.output <- rbind(data.woody, data.nonwoody)
                      # Add the transect ID, reverse engineered from the max column index
                      data.output$transect.id <- (max(X) - 1)/4
                      return(data.output)
                    }, data = data.raw)

# Luckily, dplyr::bind_rows() will combine the whole list into a single data frame
data.tall <- dplyr::bind_rows(data.list)
```

I still need to add  in the protocol column and the metadata, but that's comparatively easy.
```{r meta, warning = FALSE}
# I use mutate to create a variable called protocol that's "aim" if a Point value started with "AIM" and "haf" if it didn't
# I also use it to create a variable called point that contains only the numeric values from Point
data <- dplyr::mutate(.data = data.tall,
                      protocol = dplyr::if_else(grepl(Point,
                                                      pattern = "^AIM",
                                                      ignore.case = TRUE),
                                                true = "aim",
                                                false = "haf"),
                      point = stringr::str_extract(Point, pattern = "\\d{1,4}"))

# Now we just add in the metadata
# First we drop the "Plot" at the front of the plot ID and write it in
data$plot.id <- trimws(gsub(metadata[1],
                            pattern = "^plot[:]{0,1} ",
                            replacement = "",
                            ignore.case = TRUE))

# Then we pray that the date can be coerced by lubridate::as_date()
# If it can't, then that's someone else's problem for the future because I don't want to deal with it right now
data$date.sampled <- if(!is.na(lubridate::as_date(metadata[2]))){lubridate::as_date(metadata[2])}else{metadata[2]}

```

And now it's just a matter of reordering it and admiring my handiwork!

It should be noted that this doesn't clean out the places where they recorded incorrect or impossible values. That's beyond the tidying step, so I don't particularly care.
```{r}
data.tidy <- dplyr::select(data, date.sampled, plot.id, transect.id, point, protocol, height.units, veg.type, species.code, height)

data.tidy
```

